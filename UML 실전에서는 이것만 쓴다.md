# UML 실전에서는 이것만 쓴다

### 1장. 개요

- 다이어그램의 유형은 논리적 구조를 보여주는 정적 다이어그램, 소프트웨어 내부의 실체가 실행 과정에서 어떻게 변화하는 지를 보여주는 동적 다이어그램, 소스 코드, 바이너리 파일 등 물리적 실체와 관계를 표현해 소프트웨어의 변하지 않는 물리적 구조를 물리적 다이어그램, 총 3개로 이뤄진다.
- 주요 클래스와 관계를 보여주는 클래스 다이어그램
    - 사각형은 클래스, 화살표는 관계를 나타내며 모든 관계는 연관(association)을 표현한다.
    - 연관은 객체와 객체 사이의 참조, 메서드의 호출을 나타낸다.
    - 메서드 호출이나 참조를 통해 클래스들이 맺고 있는 관계를 표현한다.
- 런타임(시스템이 실제 실행되는 시간) 내에서 객체와 관계를 포착해 보여주는 스냅샷과 비슷한 객체 다이어그램
    - 객체는 사각형, 이름은 밑줄, 객체 사이의 관계는 연결(link)로 표기한다.
- 메서드가 어떻게 구현되고 어떤 조건에 맞춰 흘러가는지를 표현하는 시퀀스 다이어그램
    - 시스템의 흐름은 대괄호 안의 표현식인 가드(guard)를 통해 표현한다.
        - ex. [`topNode == null`]
    - 가드에 맞춰 객체에게 흘러가는 화살표는 생성(construction)을 나타내고, 화살표를 통해 전달되는 인자들은 한쪽 끝에 원이 그려진 작은 화살표로 표현하는 데이터 토큰(data token)을 통해 표현한다.
    - 메서드의 실행 시간은 활성 상자(activation)으로 표현하며 선 위에 덧대지는 세로로 긴 직사각형으로 나타낸다.
- 시퀀스 다이어그램이 메시지의 전송과 수신 순서를 명확하게 표현했다면, 협력 다이어그램은 메시지를 주고 받는 객체 사이의 관계를 표현한다.
- 객체의 메시지 전달과 이를 통해 변경되는 State Machine을 표현하는 상태 다이어그램
    - 상태는 원으로, 원을 변경시키는 행동들은 화살표로 표현한다.
        - 화살표는 전이(transition)이라고 부르며, 전이를 일으키는 이벤트와 수행 행동은 레이블로 달아놓는다.

---

### 2장. 다이어그램으로 작업하기

- 왜 우린 모델을 만들어야 할까?
    - 모델을 통해 설계를 검사하고 검증한다. 실제 구현이 완성된 소프트웨어는 모델보다 훨씬 비싸기 때문이다. 결국 비용 문제다.
    - 완성된 소프트웨어를 빌딩, 완성된 설계를 청사진이라고 해보자. 빌딩을 무너뜨리는 비용이 클까? 청사진을 구겨 쓰레기통에 던지는 비용이 클까?
- 행위를 제일 먼저 정의하라. 그 뒤에 행위를 반영하는 다이어그램을 그려라.
    - 만약 다이어그램을 그리며 코드가 떠오르지 않는다면 사상누각이다.
    - 다이어그램을 그리고 그 관계들을 상상 속에서 코드로 옮겨 보아라.
- 반드시 모든 코드 베이스의 다이어그램을 그려야 할까? 그렇진 않다. 절대 그렇지 않다.
    - 배보다 배꼽이 더 커지는 상황은 막아라. 변하지 않는 것들에게는 좋은 문서가 필요하다. 하지만 대부분의 UML의 생명주기는 짧다.
        - 복잡한 통신 프로토콜, 복잡한 RDB 스키마, 복잡한 프레임워크라면 그러하다.
        - 하지만 그 반대라면, 너무 간단한 것이나 금새 변하는 것들에 대한 문서는 필요하지 않다.
- UML은 도구일 뿐 목적이 되어서는 안된다.

---

### 4장. 시퀀스 다이어그램

- 꼭 시퀀스 다이어그램이 필요할까?
    - 사소한 차이점까지 모두 만들기엔 적절하지 않다.
    - 공통점에 초점을 맞추고 표현하라. 간결하게 절제된 형태로.
    - 코드를 직접 보여주는게 시퀀스 다이어그램보다 더 쉽고 경제적이다.
- 저차원의 세부적인 흐름보단 고차원의 다이어그램이 더 낫다.
    - 공통점을 더 많이 드러내며, 시스템의 여러 요소를 하나로 연결할 수 있게 해준다.
- 시퀀스 다이어그램이 의미있어질 상황은 이렇다.
    - 실시간 의사소통 도구로 칠판에 그리자
    - 시스템에서 되도록 변하지 않으며 두드러지게 나타나는 핵심적인 협력을 포착하기 위한 용도로 그려 문서로 남기자

---

### 5장. 유스케이스

- 유스케이스에서의 가장 핵심은 **‘내일이면 다 바뀐다’** 이다.
    - 모든 유스케이스를 파악하는 것은 불가능한 일이다.
    - 세부사항을 바로, 모두 채우지 않아도 된다.
    - 절대 유스케이스 작성을 목적으로 시간을 허비하지 말아라
    - 단순하게 유지하라

---

### 6장. 객체지향 개발의 원칙

- 나쁜 설계의 특징이다.
    - 경직성 → 변경이 다른 변경을 유발한다. 변화의 사슬의 얼마나 많고 복잡한가에 대한 지표다.
    - 부서지기 쉬움 → A를 바꿨는데 B가 고장난다.
    - 부동성 → 재사용성이 떨어진다.
    - 끈끈함 → 개발 환경이 너무 열악하다.
        - 코드 수정 → 컴파일 → 테스트 사이클이 길다.
    - 쓸데없이 복잡함 → 지금 필요하지도 않은데 언젠간 필요하겠지 싶어서 만든 기능들이 많다.
    - 필요 없는 반복
    - 불투명함
- 의존 관계를 잘 관리한다면 나쁜 설계에서 나오는 썩은 냄새는 나지 않는다.

---

### 7장. 실천 방법: dx(XP)

- 우리가 만드는 것은 소프트웨어다. 이는 대부분 팀 규모의 프로젝트 단위를 통해 진행된다. 여기서 핵심은 프로젝트 내에서 일어나는 일들을 짧은 단위로 반복하는 행위를 통해 결과를 도출하는 것이다. 해당되는 행위는 이와 같다.
    - 요구사항, 분석, 설계, 구현, 테스팅, 문서화
- 처음엔 시스템이 어떻게 작동해야 하는지, 어떤 행동을 해야 하는지를 파악한다.
    - 상세 요구사항을 추출하는 단계가 아니다. 대략적인 것을 파악한다.
    - 발견된 행위들, 유스케이스를 ‘사용자 스토리’ 라고 부르며 이를 별도로 기록한다.
    - 사용자 스토리 구현에 필요한 시간은 우리의 경험을 토대로 추정한다. 처음이라면 ‘완벽한 하루’ 라는 개념을 사용해본다.
        - 완벽한 하루란 ‘오롯이 모든 시간을 해당 구현에 사용할 수 있는 하루’ 라는 가정이다.
    - 추정치를 세운 뒤엔 스파이크(미리 몇개를 구현해보는)를 통해 추정치가 얼마나 정확한지 판단한다.
    - 이를 통해 우리 팀이 특정 기간동안 얼마나 스토리를 구현하는지 파악해 이를 **‘속도’**로 삼는다.
- 릴리즈를 계획한다.
    - 릴리즈까지 남은 시간들과 우리가 구현해야할 스토리들을 비교해보며 우선순위가 높은 것들을 먼저 시작한다.
    - 이를 구현하는 과정을 반복하며 우리 팀의 속도에 알맞게 스토리를 추가하거나 제거한다.
- 이렇게 반복 주기에서 우린 스토리들에 대해 위에서 이야기하는 행위(요구사항, 분석, 설계 등)들을 수행한다.
    - 여기서 우린 이번 반복에서 다루는 스토리에만 집중한다.
    - 언제나 페어 프로그래밍을 수행해야 한다.
    - 우리가 소프트웨어를 구현할 때 QA와 고객은 구현하는 스토리에 살을 붙여 유스케이스로 만들고 이를 테스트해볼 인수 테스트를 작성한다.
    - 개발자들은 TDD 방법론을 통해 기능들을 구현할 때마다 수많은 작은 테스트들을 추가한다.
    - 여기서 탄생한 테스트들을 기반으로 리팩터링을 진행할수도 있다.

---

### 8장. 패키지

- 패키지 설계의 원칙
- 패키지 릴리스/재사용 등가 원칙(Release/Reuse Equivalency Principle, REP)
    - 일반적으로 클래스 재사용 시 하나의 그룹 단위로 묶어 다같이 사용하는 경우가 많다. 이 때 해당 클래스들은 동일한 패키지 내에 위치해야한다.
- 공통 폐쇄 원칙(Common Closure Principle, CCP)
    - SRP의 패키지 관점 확장이다. 만약 어떤 클래스를 변경해야 한다면 이 때문에 변경이 필요한 클래스들이 하나의 패키지에 몰려있어야 한다는 원칙이다.
- 공통 재사용 원칙(Common Reuse Principle, CRP)
    - ISP의 패키지 관점 확장이다. 한 클라이언트가 사용하는 클래스들은 다른 클라이언트가 사용하는 클래스와 최대한 분리되어 있어야 한다는 원칙이다.
- 의존 관계 비순환 원칙(Acyclic Dependencies Principle, ADP)
    - 패키지 의존 관계 그래프에서는 순환이 있으면 안된다.
- 안정된 의존 관계 원칙(Stable Dependencies Principle, SDP)
- 안정된 추상화 원칙 (Stable Abstractions Principle, SAP)
    - 많은 의존 관계를 받는 패키지는 안정되어 있어야 하며 그만큼 추상적이어야 한다.