# UML 실전에서는 이것만 쓴다

### 1장. 개요

- 다이어그램의 유형은 논리적 구조를 보여주는 정적 다이어그램, 소프트웨어 내부의 실체가 실행 과정에서 어떻게 변화하는 지를 보여주는 동적 다이어그램, 소스 코드, 바이너리 파일 등 물리적 실체와 관계를 표현해 소프트웨어의 변하지 않는 물리적 구조를 물리적 다이어그램, 총 3개로 이뤄진다.
- 주요 클래스와 관계를 보여주는 클래스 다이어그램
    - 사각형은 클래스, 화살표는 관계를 나타내며 모든 관계는 연관(association)을 표현한다.
    - 연관은 객체와 객체 사이의 참조, 메서드의 호출을 나타낸다.
    - 메서드 호출이나 참조를 통해 클래스들이 맺고 있는 관계를 표현한다.
- 런타임(시스템이 실제 실행되는 시간) 내에서 객체와 관계를 포착해 보여주는 스냅샷과 비슷한 객체 다이어그램
    - 객체는 사각형, 이름은 밑줄, 객체 사이의 관계는 연결(link)로 표기한다.
- 메서드가 어떻게 구현되고 어떤 조건에 맞춰 흘러가는지를 표현하는 시퀀스 다이어그램
    - 시스템의 흐름은 대괄호 안의 표현식인 가드(guard)를 통해 표현한다.
        - ex. [`topNode == null`]
    - 가드에 맞춰 객체에게 흘러가는 화살표는 생성(construction)을 나타내고, 화살표를 통해 전달되는 인자들은 한쪽 끝에 원이 그려진 작은 화살표로 표현하는 데이터 토큰(data token)을 통해 표현한다.
    - 메서드의 실행 시간은 활성 상자(activation)으로 표현하며 선 위에 덧대지는 세로로 긴 직사각형으로 나타낸다.
- 시퀀스 다이어그램이 메시지의 전송과 수신 순서를 명확하게 표현했다면, 협력 다이어그램은 메시지를 주고 받는 객체 사이의 관계를 표현한다.
- 객체의 메시지 전달과 이를 통해 변경되는 State Machine을 표현하는 상태 다이어그램
    - 상태는 원으로, 원을 변경시키는 행동들은 화살표로 표현한다.
        - 화살표는 전이(transition)이라고 부르며, 전이를 일으키는 이벤트와 수행 행동은 레이블로 달아놓는다.

---

### 2장. 다이어그램으로 작업하기

- 왜 우린 모델을 만들어야 할까?
    - 모델을 통해 설계를 검사하고 검증한다. 실제 구현이 완성된 소프트웨어는 모델보다 훨씬 비싸기 때문이다. 결국 비용 문제다.
    - 완성된 소프트웨어를 빌딩, 완성된 설계를 청사진이라고 해보자. 빌딩을 무너뜨리는 비용이 클까? 청사진을 구겨 쓰레기통에 던지는 비용이 클까?
- 행위를 제일 먼저 정의하라. 그 뒤에 행위를 반영하는 다이어그램을 그려라.
    - 만약 다이어그램을 그리며 코드가 떠오르지 않는다면 사상누각이다.
    - 다이어그램을 그리고 그 관계들을 상상 속에서 코드로 옮겨 보아라.
- 반드시 모든 코드 베이스의 다이어그램을 그려야 할까? 그렇진 않다. 절대 그렇지 않다.
    - 배보다 배꼽이 더 커지는 상황은 막아라. 변하지 않는 것들에게는 좋은 문서가 필요하다. 하지만 대부분의 UML의 생명주기는 짧다.
        - 복잡한 통신 프로토콜, 복잡한 RDB 스키마, 복잡한 프레임워크라면 그러하다.
        - 하지만 그 반대라면, 너무 간단한 것이나 금새 변하는 것들에 대한 문서는 필요하지 않다.
- UML은 도구일 뿐 목적이 되어서는 안된다.

---

### 4장. 시퀀스 다이어그램

- 꼭 시퀀스 다이어그램이 필요할까?
    - 사소한 차이점까지 모두 만들기엔 적절하지 않다.
    - 공통점에 초점을 맞추고 표현하라. 간결하게 절제된 형태로.
    - 코드를 직접 보여주는게 시퀀스 다이어그램보다 더 쉽고 경제적이다.
- 저차원의 세부적인 흐름보단 고차원의 다이어그램이 더 낫다.
    - 공통점을 더 많이 드러내며, 시스템의 여러 요소를 하나로 연결할 수 있게 해준다.
- 시퀀스 다이어그램이 의미있어질 상황은 이렇다.
    - 실시간 의사소통 도구로 칠판에 그리자
    - 시스템에서 되도록 변하지 않으며 두드러지게 나타나는 핵심적인 협력을 포착하기 위한 용도로 그려 문서로 남기자

---

### 5장. 유스케이스

- 유스케이스에서의 가장 핵심은 **‘내일이면 다 바뀐다’** 이다.
    - 모든 유스케이스를 파악하는 것은 불가능한 일이다.
    - 세부사항을 바로, 모두 채우지 않아도 된다.
    - 절대 유스케이스 작성을 목적으로 시간을 허비하지 말아라
    - 단순하게 유지하라

---

### 6장. 객체지향 개발의 원칙

- 나쁜 설계의 특징이다.
    - 경직성 → 변경이 다른 변경을 유발한다. 변화의 사슬의 얼마나 많고 복잡한가에 대한 지표다.
    - 부서지기 쉬움 → A를 바꿨는데 B가 고장난다.
    - 부동성 → 재사용성이 떨어진다.
    - 끈끈함 → 개발 환경이 너무 열악하다.
        - 코드 수정 → 컴파일 → 테스트 사이클이 길다.
    - 쓸데없이 복잡함 → 지금 필요하지도 않은데 언젠간 필요하겠지 싶어서 만든 기능들이 많다.
    - 필요 없는 반복
    - 불투명함
- 의존 관계를 잘 관리한다면 나쁜 설계에서 나오는 썩은 냄새는 나지 않는다.